<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Expander</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: Arial, sans-serif;
            position: relative;
        }
        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #canvas-container {
            position: relative;
        }
        .caption-input {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 5px 10px;
            width: 400px;
            z-index: 10;
        }
        .caption-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
        }
        #caption-line1 {
            top: calc(50vh - 230px);
        }
        #caption-line2 {
            top: calc(50vh - 200px);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <input type="text" id="caption-line1" class="caption-input" value="The ball gets bigger" />
    <input type="text" id="caption-line2" class="caption-input" value="Until my phone crashes ðŸ’€" />
    <script>
        // ============================================
        // BALL EXPANDER - p5.js
        // ============================================
        // Simulation Parameters
        const BOUNDARY_RADIUS = 150;
        const INITIAL_BALL_RADIUS = 8.25;
        const BALL_RADIUS = INITIAL_BALL_RADIUS; // Will be overridden by ball instance
        const CANVAS_SIZE = 800;
        const CENTER_X = CANVAS_SIZE / 2;
        const CENTER_Y = CANVAS_SIZE / 2;
        
        const BALL_SPEED = 550; // Constant speed in pixels per second (maintained regardless of size)
        const GRAVITY = 1470; // Downward acceleration in pixels per second squared (50% stronger than before)
        const BOUNCE_DAMPING = 0.95; // Bounciness factor (0-1, higher = more bouncy)
        const BOUNCE_ANGLE_VARIANCE = 20 * (Math.PI / 180); // 20 degrees in radians for bounce randomness
        
        // Color cycle for ball (30% slower)
        const BALL_COLOR_CYCLE_MIN = 3.25;
        const BALL_COLOR_CYCLE_MAX = 3.9;
        
        // Global state
        let ball = null;
        let lastFrameTime = 0;
        let isRunning = false;
        let explosions = []; // Array to store active explosions
        
        // Caption input elements
        let captionInput1 = null;
        let captionInput2 = null;
        
        // Button state
        const BUTTON_X = CENTER_X;
        const BUTTON_Y = CENTER_Y - 70;
        const BUTTON_WIDTH = 120;
        const BUTTON_HEIGHT = 50;
        let buttonHovered = false;
        
        // Audio context for sound effects
        let audioContext = null;
        
        // Initialize audio context (lazy initialization)
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // Resume audio context if suspended (required by some browsers)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }
            return audioContext;
        }
        
        // Play a clear glass-like sound that starts low and goes higher
        function playCollisionSound(pitch = 1.0, isBoundary = false, bounceCount = 0) {
            try {
                const ctx = initAudioContext();
                
                // Resume audio context if suspended (required for immediate playback)
                if (ctx.state === 'suspended') {
                    ctx.resume();
                }
                
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                
                // Connect oscillator to gain node to output
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                
                // Use sine wave for clear, glass-like sound
                oscillator.type = 'sine';
                
                // Linear progression: start at 200 Hz, increase by 3 Hz per bounce
                const startFreq = 200;
                const freqIncrease = 3;
                const frequency = startFreq + (bounceCount * freqIncrease);
                
                oscillator.frequency.value = frequency;
                
                // Clean, crisp envelope for glass-like sound (maximum volume)
                const now = ctx.currentTime;
                gainNode.gain.setValueAtTime(1.0, now); // Maximum volume
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15); // Smooth decay
                
                // Start and stop the oscillator
                oscillator.start(now);
                oscillator.stop(now + 0.15);
                
            } catch (e) {
                // Silently fail if audio context can't be created (e.g., user interaction required)
                console.log('Audio not available:', e);
            }
        }
        
        // Play bounce sound effect (wrapper for boundary collisions)
        function playBounceSound(bounceCount = 0) {
            playCollisionSound(1.0, true, bounceCount);
        }
        
        // Explosion class for collision effects
        class Explosion {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.age = 0;
                this.duration = 0.5; // Duration in seconds (longer for visibility)
                this.maxSize = 41; // 20% bigger than before (34 * 1.2)
                this.particles = [];
                
                // Create particles for explosion (20% bigger)
                const particleCount = 24;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const speed = 48 + Math.random() * 60; // 20% faster particles
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: 4 + Math.random() * 5, // 20% bigger particles
                        life: 1.0
                    });
                }
            }
            
            update(deltaTime) {
                this.age += deltaTime;
                
                // Update particles
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    p.vx *= 0.95; // Friction
                    p.vy *= 0.95;
                    p.life -= deltaTime / this.duration;
                }
            }
            
            draw() {
                const progress = this.age / this.duration;
                if (progress >= 1) return;
                
                const alpha = 255 * (1 - progress);
                
                // Draw particles (more vibrant)
                noStroke();
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    if (p.life > 0) {
                        const particleAlpha = alpha * p.life; // Full brightness
                        // Much brighter colors for more vibrancy
                        const brightColor = [
                            Math.min(255, Math.floor(this.color[0] * 1.8)),
                            Math.min(255, Math.floor(this.color[1] * 1.8)),
                            Math.min(255, Math.floor(this.color[2] * 1.8))
                        ];
                        fill(brightColor[0], brightColor[1], brightColor[2], particleAlpha);
                        ellipse(p.x, p.y, p.size * p.life, p.size * p.life);
                    }
                }
                
                // Draw central burst (smaller but more vibrant)
                const burstSize = this.maxSize * progress;
                // Much brighter colors for maximum vibrancy
                const brightColor = [
                    Math.min(255, Math.floor(this.color[0] * 2.0)),
                    Math.min(255, Math.floor(this.color[1] * 2.0)),
                    Math.min(255, Math.floor(this.color[2] * 2.0))
                ];
                fill(brightColor[0], brightColor[1], brightColor[2], alpha * 0.9); // Very opaque
                ellipse(this.x, this.y, burstSize, burstSize);
                
                // Add outer glow for extra visibility (20% bigger)
                fill(brightColor[0], brightColor[1], brightColor[2], alpha * 0.5);
                ellipse(this.x, this.y, burstSize * 1.4, burstSize * 1.4);
            }
            
            isDead() {
                return this.age >= this.duration;
            }
        }
        
        // Ball class
        class Ball {
            constructor(spawnX, spawnY) {
                this.x = spawnX;
                this.y = spawnY;
                
                // Store starting Y position to prevent bouncing above it
                this.startY = spawnY;
                
                // Ball radius starts at 30% size (70% less) and grows on collisions
                this.radius = INITIAL_BALL_RADIUS * 0.3;
                
                // Initial velocity: drop at 20 degrees to the right
                const dropAngle = 20 * (Math.PI / 180); // 20 degrees in radians
                this.vx = BALL_SPEED * Math.sin(dropAngle); // Rightward component
                this.vy = BALL_SPEED * Math.cos(dropAngle); // Downward component
                
                // Ball state
                this.ballColorTimer = 0;
                this.ballColorCycleDuration = BALL_COLOR_CYCLE_MIN + Math.random() * (BALL_COLOR_CYCLE_MAX - BALL_COLOR_CYCLE_MIN);
                
                
                // Lines attached from collision points
                this.collisionLines = [];
                
                // Bounce counter
                this.bounceCount = 0;
                
                // Speed multiplier increases by 0.5% with each bounce
                this.speedMultiplier = 1.0;
            }
            
            update(deltaTime) {
                // Cap deltaTime to prevent huge jumps
                deltaTime = Math.min(deltaTime, 1/30);
                
                // Update ball's color timer
                this.ballColorTimer = (this.ballColorTimer + deltaTime) % this.ballColorCycleDuration;
                
                // Maintain constant speed regardless of ball size
                // Speed increases by 0.5% with each bounce
                const targetSpeed = BALL_SPEED * this.speedMultiplier;
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (currentSpeed > 0) {
                    // Normalize velocity to maintain constant speed magnitude
                    const speedRatio = targetSpeed / currentSpeed;
                    this.vx *= speedRatio;
                    this.vy *= speedRatio;
                }
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Check collision with circle boundary
                const dx = this.x - CENTER_X;
                const dy = this.y - CENTER_Y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                const effectiveRadius = BOUNDARY_RADIUS - this.radius;
                
                // Check if ball is outside boundary
                if (distance > effectiveRadius) {
                    // Collision occurred - bouncy elastic bounce
                    const normalX = Math.cos(angle);
                    const normalY = Math.sin(angle);
                    
                    // Store collision point on boundary for line attachment (before growth)
                    const collisionX = CENTER_X + normalX * BOUNDARY_RADIUS;
                    const collisionY = CENTER_Y + normalY * BOUNDARY_RADIUS;
                    this.collisionLines.push({
                        startX: collisionX,
                        startY: collisionY
                    });
                    
                    // Create explosion at collision point
                    const ballColor = this.getBallColor();
                    explosions.push(new Explosion(collisionX, collisionY, ballColor));
                    
                    // Increment bounce counter
                    this.bounceCount++;
                    
                    // Increase speed by 0.5% with each bounce
                    this.speedMultiplier *= 1.005;
                    
                    // Play bounce sound with melodic variation based on bounce count
                    playBounceSound(this.bounceCount);
                    
                    // Grow ball by 1.05x (5%)
                    this.radius *= 1.05;
                    
                    // Recalculate effective radius after growth
                    const newEffectiveRadius = BOUNDARY_RADIUS - this.radius;
                    
                    // Ensure ball stays inside boundary
                    if (newEffectiveRadius > 0) {
                        // Push ball back inside boundary
                        this.x = CENTER_X + normalX * newEffectiveRadius;
                        this.y = CENTER_Y + normalY * newEffectiveRadius;
                    } else {
                        // Ball is too big, keep it at the boundary
                        this.x = CENTER_X + normalX * (BOUNDARY_RADIUS - 0.1);
                        this.y = CENTER_Y + normalY * (BOUNDARY_RADIUS - 0.1);
                    }
                    
                    // Reflect velocity vector
                    const dot = this.vx * normalX + this.vy * normalY;
                    this.vx = this.vx - 2 * dot * normalX;
                    this.vy = this.vy - 2 * dot * normalY;
                    
                    // Add random angle variation (Â±20 degrees)
                    const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (currentSpeed > 0) {
                        const currentAngle = Math.atan2(this.vy, this.vx);
                        const randomVariation = (Math.random() * 2 - 1) * BOUNCE_ANGLE_VARIANCE;
                        const newAngle = currentAngle + randomVariation;
                        this.vx = Math.cos(newAngle) * currentSpeed;
                        this.vy = Math.sin(newAngle) * currentSpeed;
                    }
                    
                    // Maintain constant speed after bounce
                    // Speed increases by 0.5% with each bounce
                    const targetSpeed = BALL_SPEED * this.speedMultiplier;
                    const postBounceSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (postBounceSpeed > 0) {
                        const speedRatio = targetSpeed / postBounceSpeed;
                        this.vx *= speedRatio;
                        this.vy *= speedRatio;
                    }
                }
            }
            
            // Get color based on ball's timer (with cyan and dark purple)
            getBallColor() {
                const normalizedTime = this.ballColorTimer / this.ballColorCycleDuration;
                
                let red, green, blue;
                
                // 5-color cycle: red -> green -> blue -> cyan -> dark purple -> red
                if (normalizedTime < 1/5) {
                    const progress = normalizedTime * 5;
                    red = Math.floor(255 * (1 - progress));
                    green = Math.floor(255 * progress);
                    blue = 0;
                } else if (normalizedTime < 2/5) {
                    const progress = (normalizedTime - 1/5) * 5;
                    red = 0;
                    green = Math.floor(255 * (1 - progress));
                    blue = Math.floor(255 * progress);
                } else if (normalizedTime < 3/5) {
                    // Blue to cyan: blue stays max, green increases
                    const progress = (normalizedTime - 2/5) * 5;
                    red = 0;
                    green = Math.floor(255 * progress);
                    blue = 255; // Full blue
                } else if (normalizedTime < 4/5) {
                    // Cyan to dark purple: green decreases, red increases, blue stays
                    const progress = (normalizedTime - 3/5) * 5;
                    red = Math.floor(128 * progress); // Dark purple red component
                    green = Math.floor(255 * (1 - progress));
                    blue = 255; // Full blue
                } else {
                    // Dark purple back to red: blue decreases, red increases
                    const progress = (normalizedTime - 4/5) * 5;
                    red = Math.floor(128 + (127 * progress)); // From 128 to 255
                    green = 0;
                    blue = Math.floor(255 * (1 - progress));
                }
                
                red = Math.min(255, Math.floor(red * 1.15));
                green = Math.min(255, Math.floor(green * 1.15));
                blue = Math.min(255, Math.floor(blue * 1.15));
                
                return [red, green, blue];
            }
            
            draw() {
                const color = this.getBallColor();
                
                // Draw collision lines (thin lines from collision points to ball)
                if (this.collisionLines.length > 0) {
                    // Brighten the color for better visibility
                    const brightColor = [
                        Math.min(255, Math.floor(color[0] * 1.3)),
                        Math.min(255, Math.floor(color[1] * 1.3)),
                        Math.min(255, Math.floor(color[2] * 1.3))
                    ];
                    stroke(brightColor[0], brightColor[1], brightColor[2], 255);
                    strokeWeight(2);
                    for (let i = 0; i < this.collisionLines.length; i++) {
                        const lineData = this.collisionLines[i];
                        // Draw line from collision point on boundary to current ball position
                        line(lineData.startX, lineData.startY, this.x, this.y);
                    }
                }
                
                // Draw glass-like ball
                noStroke();
                
                // Outer glow
                fill(color[0], color[1], color[2], 40);
                ellipse(this.x, this.y, this.radius * 2 + 4, this.radius * 2 + 4);
                
                // Middle glow
                fill(color[0], color[1], color[2], 80);
                ellipse(this.x, this.y, this.radius * 2 + 2, this.radius * 2 + 2);
                
                // Main ball body
                fill(color[0], color[1], color[2], 200);
                ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
                
                // Outer stroke (colored)
                noFill();
                stroke(color[0], color[1], color[2], 220);
                strokeWeight(2);
                ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
                
                // Faint white outline
                noFill();
                stroke(255, 255, 255, 220);
                strokeWeight(1);
                ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
            }
        }
        
        // Setup function
        function setup() {
            const canvas = createCanvas(CANVAS_SIZE, CANVAS_SIZE);
            canvas.parent('canvas-container');
            background(0);
            lastFrameTime = millis();
            
            // Create ball at center (but don't start yet)
            ball = new Ball(CENTER_X, CENTER_Y);
            
            // Initialize caption inputs
            captionInput1 = document.getElementById('caption-line1');
            captionInput2 = document.getElementById('caption-line2');
        }
        
        // Draw function
        function draw() {
            // Clear canvas
            background(0);
            
            // Draw circle boundary (no gap)
            drawBoundary();
            
            // Show/hide caption inputs based on running state
            if (captionInput1 && captionInput2) {
                if (isRunning) {
                    captionInput1.style.display = 'none';
                    captionInput2.style.display = 'none';
                } else {
                    captionInput1.style.display = 'block';
                    captionInput2.style.display = 'block';
                }
            }
            
            // Draw caption (always visible)
            drawCaption();
            
            // Draw button only if not running
            if (!isRunning) {
                drawButton();
            }
            
            // Draw bounce counter
            if (ball) {
                drawBounceCounter();
            }
            
            // Only update ball if running
            if (isRunning && ball) {
                // Calculate delta time
                const currentTime = millis();
                const deltaTime = (currentTime - lastFrameTime) / 1000.0;
                lastFrameTime = currentTime;
                
                ball.update(deltaTime);
                ball.draw();
                
                // Update and draw explosions
                for (let i = explosions.length - 1; i >= 0; i--) {
                    explosions[i].update(deltaTime);
                    explosions[i].draw();
                    if (explosions[i].isDead()) {
                        explosions.splice(i, 1);
                    }
                }
            } else if (ball) {
                // Draw ball in starting position
                ball.draw();
            }
        }
        
        // Draw caption
        function drawCaption() {
            textAlign(CENTER, CENTER);
            textSize(24);
            fill(255);
            noStroke();
            
            // Get caption text from inputs if available, otherwise use defaults
            const line1 = (captionInput1 && captionInput1.value) ? captionInput1.value : "The ball gets bigger";
            const line2 = (captionInput2 && captionInput2.value) ? captionInput2.value : "Until my phone crashes ðŸ’€";
            
            text(line1, CENTER_X, CENTER_Y - 230);
            text(line2, CENTER_X, CENTER_Y - 200);
        }
        
        // Draw bounce counter
        function drawBounceCounter() {
            textAlign(CENTER, CENTER);
            textSize(20);
            fill(255);
            noStroke();
            const bounceText = "Bounces: " + (ball ? ball.bounceCount : 0);
            text(bounceText, CENTER_X, CENTER_Y + 200);
        }
        
        // Draw start button
        function drawButton() {
            // Check if mouse is over button
            const mouseX_canvas = mouseX;
            const mouseY_canvas = mouseY;
            buttonHovered = (
                mouseX_canvas > BUTTON_X - BUTTON_WIDTH / 2 &&
                mouseX_canvas < BUTTON_X + BUTTON_WIDTH / 2 &&
                mouseY_canvas > BUTTON_Y - BUTTON_HEIGHT / 2 &&
                mouseY_canvas < BUTTON_Y + BUTTON_HEIGHT / 2
            );
            
            // Draw button
            noStroke();
            
            // Button shadow/glow
            if (buttonHovered) {
                fill(102, 126, 234, 60);
                ellipse(BUTTON_X, BUTTON_Y + 2, BUTTON_WIDTH + 4, BUTTON_HEIGHT + 4);
            }
            
            // Button gradient effect (simulated)
            fill(102, 126, 234);
            rect(BUTTON_X - BUTTON_WIDTH / 2, BUTTON_Y - BUTTON_HEIGHT / 2, BUTTON_WIDTH, BUTTON_HEIGHT, 25);
            
            // Button highlight
            fill(118, 75, 162);
            rect(BUTTON_X - BUTTON_WIDTH / 2, BUTTON_Y - BUTTON_HEIGHT / 2, BUTTON_WIDTH, BUTTON_HEIGHT / 2, 25, 25, 0, 0);
            
            // Button text
            textAlign(CENTER, CENTER);
            textSize(18);
            fill(255);
            textStyle(BOLD);
            text("Start", BUTTON_X, BUTTON_Y);
            textStyle(NORMAL);
        }
        
        // Handle mouse clicks
        function mousePressed() {
            // Initialize audio on first user interaction
            initAudioContext();
            
            if (!isRunning) {
                const mouseX_canvas = mouseX;
                const mouseY_canvas = mouseY;
                
                // Check if button was clicked
                if (
                    mouseX_canvas > BUTTON_X - BUTTON_WIDTH / 2 &&
                    mouseX_canvas < BUTTON_X + BUTTON_WIDTH / 2 &&
                    mouseY_canvas > BUTTON_Y - BUTTON_HEIGHT / 2 &&
                    mouseY_canvas < BUTTON_Y + BUTTON_HEIGHT / 2
                ) {
                    isRunning = true;
                    // Reset ball and clear explosions
                    ball = new Ball(CENTER_X, CENTER_Y);
                    explosions = [];
                    lastFrameTime = millis();
                }
            }
        }
        
        // Draw the boundary circle (no gap)
        function drawBoundary() {
            const centerX = CANVAS_SIZE / 2;
            const centerY = CANVAS_SIZE / 2;
            
            // Color cycling (with cyan and dark purple, matching ball)
            const colorTimer = (millis() / 1000.0) % 5.0;
            const normalizedTime = colorTimer / 5.0;
            
            let red, green, blue;
            
            // 5-color cycle: red -> green -> blue -> cyan -> dark purple -> red
            if (normalizedTime < 1/5) {
                const progress = normalizedTime * 5;
                red = Math.floor(255 * (1 - progress));
                green = Math.floor(255 * progress);
                blue = 0;
            } else if (normalizedTime < 2/5) {
                const progress = (normalizedTime - 1/5) * 5;
                red = 0;
                green = Math.floor(255 * (1 - progress));
                blue = Math.floor(255 * progress);
            } else if (normalizedTime < 3/5) {
                // Blue to cyan: blue stays max, green increases
                const progress = (normalizedTime - 2/5) * 5;
                red = 0;
                green = Math.floor(255 * progress);
                blue = 255; // Full blue
            } else if (normalizedTime < 4/5) {
                // Cyan to dark purple: green decreases, red increases, blue stays
                const progress = (normalizedTime - 3/5) * 5;
                red = Math.floor(128 * progress); // Dark purple red component
                green = Math.floor(255 * (1 - progress));
                blue = 255; // Full blue
            } else {
                // Dark purple back to red: blue decreases, red increases
                const progress = (normalizedTime - 4/5) * 5;
                red = Math.floor(128 + (127 * progress)); // From 128 to 255
                green = 0;
                blue = Math.floor(255 * (1 - progress));
            }
            
            red = Math.min(255, Math.floor(red * 1.15));
            green = Math.min(255, Math.floor(green * 1.15));
            blue = Math.min(255, Math.floor(blue * 1.15));
            
            const boundaryColor = [red, green, blue];
            
            // Draw colored circle outline (no white parts)
            noFill();
            
            // Outer glow layer
            stroke(boundaryColor[0], boundaryColor[1], boundaryColor[2], 60);
            strokeWeight(10);
            ellipse(centerX, centerY, BOUNDARY_RADIUS * 2 + 2, BOUNDARY_RADIUS * 2 + 2);
            
            // Middle glow layer
            stroke(boundaryColor[0], boundaryColor[1], boundaryColor[2], 100);
            strokeWeight(7);
            ellipse(centerX, centerY, BOUNDARY_RADIUS * 2 + 1, BOUNDARY_RADIUS * 2 + 1);
            
            // Main stroke
            stroke(boundaryColor[0], boundaryColor[1], boundaryColor[2], 220);
            strokeWeight(5);
            ellipse(centerX, centerY, BOUNDARY_RADIUS * 2, BOUNDARY_RADIUS * 2);
            
            // Inner glow (colored, no white highlight)
            stroke(boundaryColor[0], boundaryColor[1], boundaryColor[2], 80);
            strokeWeight(3);
            ellipse(centerX, centerY, BOUNDARY_RADIUS * 2 - 1, BOUNDARY_RADIUS * 2 - 1);
        }
    </script>
</body>
</html>

